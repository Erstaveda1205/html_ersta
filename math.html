<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATEMATIKA</title>
    <link rel="stylesheet" href="math.css">
</head>
<body>
    <header>
        <h1>MATEMATIKA KELAS X (10)</h1>
        <p> MATERI ALGORITMA</p> 
    </header>
    <h1 class="judul">PENGERTIAN ALGORITMA</h1>
    <p></p>
    <p>Algoritma merupakan sekumpulan instruksi atau langkah-langkah yang dituliskan secara sistematis dan digunakan untuk menyelesaikan masalah / persoalan logika dan matematika dengan bantuan komputer (Sismoro, 2005, 29).</p>
    <p>Algoritma menurut (Kani, 2020, 1.19) adalah suatu upaya dengan urutan operasi yang disusun secara logis dan sistematis untuk menyelesaikan suatu masalah untuk menghasilkan suatu output tertentu.</p>
    <p>Algoritma berasal dari kata algoris dan ritmis yang pertama kali diperkenalkan oleh Abu Jaâ€™far Muhammad Ibn Musa Al Khwarizmi pada 825 M di dalam buku Al-Jabr Wa-al Muqabla. Dalam bidang pemrograman, algoritma dide?nisikan sebagai metode yang terdiri dari serangkaian langkah yang terstruktur dan sistematis untuk menyelesaikan masalah dengan bantuan komputer (Jando & Nani, 2018, 5).</p>
    <p>Algoritma menurut (Munir & Lidya, 2016, 5) adalah urutan langkah-langkah untuk menyelesaikan suatu persoalan.</p>
    <h1 class="fungsi-algoritma">FUNGSI ALGORITMA</h1>
    <P></P>
    <P>Seorang matematikawan dan ilmuwan komputer bernama Dr. Christoph Koutschan mengatakan bahwa setidaknya ada 32 algoritma dalam ilmu komputer. Namun jika dilihat dari fungsinya, hanya ada enam algoritma dasar, yaitu </P>
    <LI><b><i>Rekursi</i></b> Sebuah algoritma rekursi adalah sesuatu yang akan memanggil dirinya sendiri berulang-ulang sehingga masalah dapat diselesaikan dengan benar. Berikut adalah beberapa kode yang dapat menemukan faktorial menggunakan algoritma rekursi.</LI>
    <li><b><i>Divide and Conquer</i></b> Divide and Conquer akan membagi masalah besar menjadi banyak menjadi masalah kecil. Jenis algoritma ini sendiri sebenarnya terdiri dari dua bagian utama, yaitu: Memecah masalah menjadi submasalah yang lebih independen dan lebih kecil dari masalah lain yang sejenis. Memecahkan masalah asli setelah dapat menyelesaikan masalah yang lebih kecil secara terpisah.</li>
    <li><b><i>Dynamic Programming</i></b> Dynamic Programming akan bekerja dengan mengingat hasil dari proses masa lalu dan juga menggunakannya untuk menemukan hasil baru. Dari penjelasan diatas, berarti bahwa Dynamic Programming memecahkan masalah kompleks dengan memecahnya menjadi banyak submasalah sederhana, kemudian menyelesaikannya satu per satu, lalu menyimpannya untuk digunakan di masa mendatang.</li>
    <li><i><b> Greedy</b></i> Tipe ini dapat digunakan untuk menyelesaikan masalah optimasi. Dalam algoritma ini, kita akan menemukan solusi yang lebih optimal secara lokal tanpa mengkhawatirkan konsekuensi yang akan terjadi di masa depan dan kita dapat menemukan solusi yang lebih optimal secara global.</li>
    <li><i><b>Brute Force</b></i> Konsep dari algoritma ini sebenarnya sangat sederhana. Selama proses ini, brute force mengintegrasikan semua solusi yang mungkin untuk menemukan satu atau lebih solusi yang mungkin untuk memecahkan masalah.</li>
    <li><b><i>Algoritma Backtracking</i></b> Backtracking adalah teknik yang dapat memecahkan masalah yang berbeda secara rekursi dan mencoba mereka untuk menemukan solusi dengan memecahkan satu bagian dari masalah pada waktu yang sama. Jika solusi gagal, kita dapat menghapusnya dan kembali mencari solusi lain. Artinya algoritma ini akan menyelesaikan sub masalah dan jika gagal maka algoritma akan membatalkan langkah terakhir dan memulai kembali untuk mencari solusi dari masalah tersebut.</li>
    <h1 class="karakteristik-algoritma">KARAKTERISTIK ALGORITMA</h1>
    <p>Menurut Donald E. Knuth, algoritma harus memiliki lima karakteristik penting yang saling berhubungan. Kriteria untuk algoritma ini meliputi:</p>
    <li><b><i>Finiteness (Keterbatasan)</i></b> Algoritma harus berhenti setelah mengambil sejumlah langkah yang terbatas, yaitu ada tujuan akhir yang tercapai, sehingga program akan berhenti ketika tujuan akhir telah tercapai. Program yang tidak pernah berhenti menunjukkan bahwa program tersebut mengandung algoritma yang salah.</li> 
    <li><i><b>Definiteness (Kepastian)</b></i>  Setiap langkah harus didefinisikan dengan tepat dan tidak ambigu. Ada instruksi yang jelas dan tidak ambigu, sehingga tidak ada kesalahan dalam menghasilkan output.</li>
    <li><b><i>Input (Masukan)</i></b> Input ini adalah masalah yang diketahui dan solusi akan diselidiki. Algoritma ini tidak memiliki atau lebih input, yang merupakan jumlah yang disediakan untuk algoritma untuk diproses.</li>
    <li><b><i>Output (Keluar)</i></b>Algoritma tidak memiliki atau lebih nilai output. Output ini tentunya harus menjadi solusi atau solusi dari suatu masalah. Output dapat berupa pesan atau kuantitas yang terkait dengan input.</li>
    <li><i><b>Effectiveness (keefektivitasan)</b></i> Algoritma harus efisien, setiap urutan atau langkah harus sesederhana mungkin, sehingga dapat diimplementasikan dalam waktu yang wajar.</li>

</body>
<p></p>
<footer><h3><b>&copy 2023 araya griseldis</b></h3></footer>
</html>